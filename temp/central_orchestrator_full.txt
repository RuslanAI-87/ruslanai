# central_orchestrator.py - Обновленная версия с расширенными возможностями
import os
import logging
import json
import subprocess
import webbrowser
import sys
import requests
import shutil
import psutil
import tempfile
from typing import Dict, Any, List, Optional, Union
from datetime import datetime
import time

# Настройка логирования
os.makedirs("C:/RuslanAI/logs", exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    filename="C:/RuslanAI/logs/central_agent.log"
)
logger = logging.getLogger(__name__)

# Создание консольного логгера для вывода в терминал
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
console_handler.setFormatter(console_formatter)
logger.addHandler(console_handler)

# Импорт библиотек LangChain
try:
    from langchain_openai import ChatOpenAI
    from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
    from langchain.memory import ConversationBufferMemory
    from langchain_core.messages import HumanMessage, AIMessage
    langchain_available = True
    logger.info("LangChain успешно импортирован")
except ImportError as e:
    logger.error(f"Ошибка импорта LangChain: {e}")
    langchain_available = False

# Для доступа к SEO-аналитику
sys.path.append("C:/RuslanAI/agents/seo_analyst")
try:
    from seo_analyst import analyze_url
    logger.info("SEO-аналитик успешно импортирован")
    seo_analyst_available = True
except ImportError as e:
    logger.error(f"Ошибка импорта SEO-аналитика: {e}")
    seo_analyst_available = False

# Для доступа к критику
sys.path.append("C:/RuslanAI/agents/critic")
try:
    from critic_agent import CriticAgent
    logger.info("Агент-критик успешно импортирован")
    critic_available = True
except ImportError as e:
    logger.error(f"Ошибка импорта агента-критика: {e}")
    critic_available = False

# Настройка API ключа
OPENAI_API_KEY = "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"

# Константы для работы с файловой системой
BASE_DIR = "C:/"
SCRIPTS_DIR = "C:/RuslanAI/scripts"
if not os.path.exists(SCRIPTS_DIR):
    os.makedirs(SCRIPTS_DIR, exist_ok=True)

# Класс для отслеживания расхода токенов и стоимости
class UsageTracker:
    def __init__(self):
        self.input_tokens = 0
        self.output_tokens = 0
        self.model = "gpt-4o"
        self.start_time = None
        self.end_time = None
        self.rates = {
            "gpt-3.5-turbo": {"input": 0.0015, "output": 0.002},  # $ per 1K tokens
            "gpt-4o": {"input": 0.01, "output": 0.03}             # $ per 1K tokens
        }
        
    def start_tracking(self):
        self.start_time = datetime.now()
        
    def end_tracking(self):
        self.end_time = datetime.now()
        
    def add_usage(self, input_tokens, output_tokens):
        self.input_tokens += input_tokens
        self.output_tokens += output_tokens
        
    def calculate_cost(self):
        rates = self.rates.get(self.model, self.rates["gpt-4o"])
        input_cost = (self.input_tokens / 1000) * rates["input"]
        output_cost = (self.output_tokens / 1000) * rates["output"]
        total_cost = input_cost + output_cost
        return {
            "input_tokens": self.input_tokens,
            "output_tokens": self.output_tokens,
            "input_cost": round(input_cost, 4),
            "output_cost": round(output_cost, 4),
            "total_cost": round(total_cost, 4),
            "currency": "USD"
        }
        
    def get_duration(self):
        if not self.start_time:
            return "Не начато"
        end = self.end_time or datetime.now()
        duration = end - self.start_time
        return str(duration).split('.')[0]  # Формат HH:MM:SS
        
    def get_status_report(self):
        cost_info = self.calculate_cost()
        duration = self.get_duration()
        return {
            "duration": duration,
            "tokens": {
                "input": self.input_tokens,
                "output": self.output_tokens,
                "total": self.input_tokens + self.output_tokens
            },
            "cost": cost_info
        }

# Функция для логирования действий системы
def log_action(action_type, details, result=None):
    """Логирование действий в отдельный файл для отслеживания"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Создаем директорию для логов, если её нет
    log_dir = "C:/RuslanAI/logs/actions"
    os.makedirs(log_dir, exist_ok=True)
    
    # Имя файла логов включает дату
    log_file = os.path.join(log_dir, f"actions_{datetime.now().strftime('%Y-%m-%d')}.log")
    
    # Формируем запись лога
    log_entry = {
        "timestamp": timestamp,
        "action": action_type,
        "details": details,
        "result": result
    }
    
    # Записываем в файл
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")
    
    # Также записываем в общий журнал
    logger.info(f"Действие: {action_type} - {details}")

# Класс центрального агента-оркестратора
class CentralOrchestrator:
    def __init__(self, api_key=OPENAI_API_KEY):
        self.api_key = api_key
        
        if langchain_available:
            self.llm = ChatOpenAI(model="gpt-4o", temperature=0, api_key=api_key)
            self.memory = ConversationBufferMemory(return_messages=True)
        else:
            logger.warning("LangChain недоступен, будет использован упрощенный режим")
        
        # Инициализация критика, если доступен
        self.critic = None
        if critic_available:
            self.critic = CriticAgent(api_key)
            logger.info("Агент-критик инициализирован")
        
        # Регистрация доступных специалистов
        self.specialists = {}
        self._register_specialists()
        
        # Создание трекера расхода
        self.usage_tracker = UsageTracker()
        
        # Определение системного промпта с расширенными возможностями
        self.system_prompt = """
        Ты - центральный агент системы RuslanAI, который координирует работу различных специализированных ассистентов 
        и обладает возможностями выполнения системных команд.
        
        Твои основные функции:
        1. Анализ запросов пользователя и понимание задач
        2. Выполнение системных команд и скриптов
        3. Управление файловой системой и автоматизация задач
        4. Координация работы между специалистами и агентом-критиком
        5. Предоставление пользователю промежуточных и финальных результатов
        
        Доступные специалисты:
        {specialists}
        
        Твои системные возможности включают:
        - Запуск shell-команд через subprocess
        - Создание и выполнение Python-скриптов
        - Работа с файловой системой (чтение, запись, копирование файлов)
        - Запуск программ
        - Загрузка файлов из интернета
        - Открытие URL в браузере
        - Мониторинг системных процессов
        
        Когда пользователь запрашивает выполнение задачи:
        1. Сначала четко определи, в чем состоит задача
        2. Если нужно использовать системные возможности, опиши план действий
        3. Предложи, как лучше выполнить задачу, и уточни детали
        4. Выполни необходимые действия, используя нужные методы
        5. Отслеживай прогресс и информируй пользователя о результатах
        
        Веди себя профессионально, но дружелюбно. Твоя цель - помочь пользователю эффективно решить его задачи.
        """
        
        # Создание директорий для логов и скриптов
        os.makedirs("C:/RuslanAI/logs", exist_ok=True)
        os.makedirs("C:/RuslanAI/scripts", exist_ok=True)
        
        logger.info("Центральный оркестратор инициализирован успешно")
        
    def _register_specialists(self):
        """Регистрация доступных специалистов"""
        if seo_analyst_available:
            self.specialists["seo_analyst"] = {
                "name": "SEO-аналитик",
                "description": "Анализирует веб-сайты на предмет SEO-оптимизации, генерирует рекомендации по улучшению",
                "capabilities": ["анализ мета-тегов", "проверка структуры URL", "аудит контента", "анализ ключевых слов"],
                "function": analyze_url
            }
            
    def get_specialists_info(self):
        """Получение информации о доступных специалистах в формате для промпта"""
        info = []
        for key, spec in self.specialists.items():
            capabilities = ", ".join(spec["capabilities"])
            info.append(f"- {spec['name']}: {spec['description']}. Возможности: {capabilities}")
        
        if not info:
            return "В данный момент нет доступных специалистов."
        return "\n".join(info)
    
    # === НОВЫЕ МЕТОДЫ ДЛЯ СИСТЕМНЫХ ОПЕРАЦИЙ ===
    
    def execute_shell_command(self, command):
        """Выполнение shell-команды и возврат результата"""
        try:
            log_action("shell_command", command)
            result = subprocess.run(command, shell=True, capture_output=True, text=True, encoding='utf-8')
            
            log_entry = {
                "stdout": result.stdout,
                "stderr": result.stderr,
                "returncode": result.returncode
            }
            log_action("shell_result", command, log_entry)
            
            return {
                "result": result.stdout,
                "error": result.stderr,
                "returncode": result.returncode,
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при выполнении команды: {str(e)}"
            log_action("shell_error", command, error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def list_files(self, path=None):
        """Получение списка файлов в директории"""
        try:
            target_path = path or BASE_DIR
            log_action("list_files", target_path)
            
            files = os.listdir(target_path)
            file_info = []
            
            for file in files:
                full_path = os.path.join(target_path, file)
                try:
                    stat_info = os.stat(full_path)
                    is_dir = os.path.isdir(full_path)
                    file_info.append({
                        "name": file,
                        "path": full_path,
                        "size": stat_info.st_size,
                        "modified": datetime.fromtimestamp(stat_info.st_mtime).strftime("%Y-%m-%d %H:%M:%S"),
                        "type": "directory" if is_dir else "file"
                    })
                except Exception as e:
                    logger.warning(f"Ошибка при получении информации о файле {full_path}: {e}")
                    file_info.append({
                        "name": file,
                        "path": full_path,
                        "error": str(e)
                    })
            
            return {
                "files": file_info,
                "directory": target_path,
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при получении списка файлов: {str(e)}"
            log_action("list_files_error", path, error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def read_file(self, path):
        """Чтение содержимого файла"""
        try:
            log_action("read_file", path)
            
            with open(path, "r", encoding="utf-8") as f:
                content = f.read()
            
            return {
                "content": content,
                "path": path,
                "size": len(content),
                "usage": self.usage_tracker.get_status_report()
            }
        except UnicodeDecodeError:
            # Попытка открыть в бинарном режиме для нетекстовых файлов
            try:
                with open(path, "rb") as f:
                    content = f.read()
                return {
                    "content": "Бинарное содержимое, невозможно отобразить в текстовом виде",
                    "path": path,
                    "size": len(content),
                    "binary": True,
                    "usage": self.usage_tracker.get_status_report()
                }
            except Exception as e:
                error_message = f"Ошибка при чтении бинарного файла: {str(e)}"
                log_action("read_file_error", path, error_message)
                return {
                    "error": error_message,
                    "usage": self.usage_tracker.get_status_report()
                }
        except Exception as e:
            error_message = f"Ошибка при чтении файла: {str(e)}"
            log_action("read_file_error", path, error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def write_file(self, path, content=None):
        """Запись содержимого в файл"""
        try:
            log_action("write_file", path)
            
            with open(path, "w", encoding="utf-8") as f:
                f.write(content or "")
            
            return {
                "result": f"Файл {path} успешно записан",
                "path": path,
                "size": len(content or ""),
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при записи файла: {str(e)}"
            log_action("write_file_error", path, error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def run_program(self, program_path, args=None):
        """Запуск программы с аргументами"""
        try:
            cmd = [program_path]
            if args:
                if isinstance(args, list):
                    cmd.extend(args)
                else:
                    cmd.append(args)
            
            log_action("run_program", program_path, args)
            
            process = subprocess.Popen(cmd)
            
            return {
                "result": f"Программа {program_path} запущена с PID {process.pid}",
                "pid": process.pid,
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при запуске программы: {str(e)}"
            log_action("run_program_error", program_path, error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def download_file(self, url, destination=None):
        """Загрузка файла по URL"""
        try:
            log_action("download_file", url, destination)
            
            if not destination:
                destination = os.path.join(tempfile.gettempdir(), os.path.basename(url))
            
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            with open(destination, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            return {
                "result": f"Файл успешно загружен в {destination}",
                "path": destination,
                "size": os.path.getsize(destination),
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при загрузке файла: {str(e)}"
            log_action("download_file_error", url, error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def open_in_browser(self, url):
        """Открытие URL в браузере"""
        try:
            log_action("open_browser", url)
            
            webbrowser.open(url)
            
            return {
                "result": f"URL {url} открыт в браузере",
                "url": url,
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при открытии URL: {str(e)}"
            log_action("open_browser_error", url, error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def get_process_list(self):
        """Получение списка запущенных процессов"""
        try:
            log_action("process_list", "Запрос списка процессов")
            
            processes = []
            for proc in psutil.process_iter(['pid', 'name', 'username', 'cpu_percent', 'memory_percent']):
                try:
                    processes.append(proc.info)
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    pass
            
            return {
                "processes": processes,
                "count": len(processes),
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при получении списка процессов: {str(e)}"
            log_action("process_list_error", "", error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def create_and_run_script(self, script_content, script_type="python", args=None):
        """Создание и запуск скрипта"""
        try:
            # Создаем уникальное имя файла
            timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
            
            if script_type.lower() == "python":
                script_path = os.path.join(SCRIPTS_DIR, f"script_{timestamp}.py")
                run_cmd = ["python", script_path]
            elif script_type.lower() == "powershell":
                script_path = os.path.join(SCRIPTS_DIR, f"script_{timestamp}.ps1")
                run_cmd = ["powershell", "-ExecutionPolicy", "Bypass", "-File", script_path]
            elif script_type.lower() == "batch" or script_type.lower() == "cmd":
                script_path = os.path.join(SCRIPTS_DIR, f"script_{timestamp}.bat")
                run_cmd = [script_path]
            else:
                return {
                    "error": f"Неподдерживаемый тип скрипта: {script_type}",
                    "usage": self.usage_tracker.get_status_report()
                }
            
            # Добавляем аргументы, если они есть
            if args:
                if isinstance(args, list):
                    run_cmd.extend(args)
                else:
                    run_cmd.append(args)
            
            # Записываем скрипт в файл
            log_action("create_script", script_path, script_type)
            with open(script_path, "w", encoding="utf-8") as f:
                f.write(script_content)
            
            # Запускаем скрипт
            log_action("run_script", script_path, run_cmd)
            result = subprocess.run(run_cmd, capture_output=True, text=True, encoding='utf-8')
            
            log_entry = {
                "stdout": result.stdout,
                "stderr": result.stderr,
                "returncode": result.returncode
            }
            log_action("script_result", script_path, log_entry)
            
            return {
                "result": "Скрипт выполнен",
                "script_path": script_path,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "returncode": result.returncode,
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при создании/запуске скрипта: {str(e)}"
            log_action("script_error", script_type, error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    def execute_python_code(self, code):
        """Выполнение произвольного Python-кода"""
        try:
            log_action("execute_python", code[:100] + ("..." if len(code) > 100 else ""))
            
            # Создаем временный файл для выполнения кода
            timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
            temp_file = os.path.join(SCRIPTS_DIR, f"exec_{timestamp}.py")
            
            with open(temp_file, "w", encoding="utf-8") as f:
                f.write(code)
            
            # Выполняем код как отдельный процесс для безопасности
            result = subprocess.run(["python", temp_file], capture_output=True, text=True, encoding='utf-8')
            
            log_entry = {
                "stdout": result.stdout,
                "stderr": result.stderr,
                "returncode": result.returncode
            }
            log_action("python_exec_result", temp_file, log_entry)
            
            return {
                "result": "Код выполнен",
                "script_path": temp_file,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "returncode": result.returncode,
                "usage": self.usage_tracker.get_status_report()
            }
        except Exception as e:
            error_message = f"Ошибка при выполнении Python-кода: {str(e)}"
            log_action("python_exec_error", "", error_message)
            return {
                "error": error_message,
                "usage": self.usage_tracker.get_status_report()
            }
    
    # === ИСХОДНЫЕ МЕТОДЫ ДЛЯ РАБОТЫ С ДИАЛОГОМ ===
    
    def start_session(self, user_request):
        """Начало новой сессии с пользователем"""
        # Сброс трекера использования
        self.usage_tracker = UsageTracker()
        self.usage_tracker.start_tracking()
        
        # Проверка, доступен ли LangChain
        if not langchain_available:
            return self._fallback_response(user_request)
        
        # Формирование промпта с учетом доступных специалистов
        specialists_info = self.get_specialists_info()
        prompt = ChatPromptTemplate.from_messages([
            ("system", self.system_prompt.format(specialists=specialists_info)),
            MessagesPlaceholder(variable_name="history"),
            ("human", "{input}")
        ])
        
        # Создание цепочки
        chain = prompt | self.llm
        
        # Запуск цепочки
        response = chain.invoke({
            "history": self.memory.chat_memory.messages,
            "input": user_request
        })
        
        # Добавление в память
        self.memory.chat_memory.add_user_message(user_request)
        self.memory.chat_memory.add_ai_message(response.content)
        
        # Оценка использования токенов
        input_tokens = len(user_request.split()) * 1.3  # Примерная оценка
        output_tokens = len(response.content.split()) * 1.3
        self.usage_tracker.add_usage(int(input_tokens), int(output_tokens))
        
        return {
            "response": response.content,
            "usage": self.usage_tracker.get_status_report()
        }
        
    def continue_conversation(self, user_message):
        """Продолжение существующей беседы"""
        # Проверка, доступен ли LangChain
        if not langchain_available:
            return self._fallback_response(user_message)
        
        prompt = ChatPromptTemplate.from_messages([
            ("system", self.system_prompt.format(specialists=self.get_specialists_info())),
            MessagesPlaceholder(variable_name="history"),
            ("human", "{input}")
        ])
        
        chain = prompt | self.llm
        
        response = chain.invoke({
            "history": self.memory.chat_memory.messages,
            "input": user_message
        })
        
        # Добавление в память
        self.memory.chat_memory.add_user_message(user_message)
        self.memory.chat_memory.add_ai_message(response.content)
        
        # Оценка использования токенов
        input_tokens = len(user_message.split()) * 1.3
        output_tokens = len(response.content.split()) * 1.3
        self.usage_tracker.add_usage(int(input_tokens), int(output_tokens))
        
        return {
            "response": response.content,
            "usage": self.usage_tracker.get_status_report()
        }
    
    def _fallback_response(self, user_message):
        """Запасной вариант ответа, если LangChain недоступен"""
        response = "Я не могу обработать ваш запрос из-за проблем с LangChain. Пожалуйста, проверьте установку библиотек."
        return {
            "response": response,
            "error": "LangChain недоступен",
            "usage": self.usage_tracker.get_status_report()
        }
        
    def execute_seo_task(self, url, task_description=None):
        """Выполнение SEO-анализа"""
        if "seo_analyst" not in self.specialists:
            return {
                "error": "SEO-аналитик недоступен",
                "usage": self.usage_tracker.get_status_report()
            }
        
        if task_description is None:
            task_description = f"Выполни SEO-аудит сайта {url} и предложи рекомендации по улучшению"
            
        # Создание уникального ID для задачи
        task_id = f"seo_{datetime.now().strftime('%Y%m%d%H%M%S')}"
            
        try:
            # Получение функции анализа
            analyze_function = self.specialists["seo_analyst"]["function"]
            
            # Запуск анализа
            start_time = time.time()
            result = analyze_function(url)
            end_time = time.time()
            
            # Оценка использования токенов (примерная)
            input_tokens = 1000  # Примерная оценка
            output_tokens = len(str(result).split()) * 1.3
            self.usage_tracker.add_usage(int(input_tokens), int(output_tokens))
            
            # Если критик доступен, проверяем результат
            if self.critic:
                logger.info(f"Отправка результата SEO-анализа на проверку критику")
                critique = self.critic.evaluate(task_description, result, "SEO-аналитик", task_id)
                
                # Если требуется доработка и это не последняя итерация
                if critique.get("needs_revision", False) and not self.critic.is_final_iteration(task_id):
                    # Здесь в будущем можно добавить логику доработки результата
                    # Сейчас просто добавляем информацию о критике
                    result = result + "\n\n--- Рекомендации критика ---\n" + json.dumps(critique, ensure_ascii=False, indent=2)
                
                return {
                    "result": result,
                    "specialist": "seo_analyst",
                    "execution_time": f"{round(end_time - start_time, 2)} сек",
                    "critique": critique,
                    "usage": self.usage_tracker.get_status_report()
                }
            else:
                # Если критик недоступен, возвращаем результат как есть
                return {
                    "result": result,
                    "specialist": "seo_analyst",
                    "execution_time": f"{round(end_time - start_time, 2)} сек",
                    "usage": self.usage_tracker.get_status_report()
                }
        except Exception as e:
            logger.error(f"Ошибка при выполнении SEO-анализа: {e}")
            return {
                "error": f"Ошибка при выполнении SEO-анализа: {str(e)}",
                "usage": self.usage_tracker.get_status_report()
            }
            
    def end_session(self):
        """Завершение сессии и получение финальной статистики"""
        self.usage_tracker.end_tracking()
        return {
            "final_usage": self.usage_tracker.get_status_report(),
            "messages_count": len(self.memory.chat_memory.messages) // 2 if langchain_available else 0,
            "session_summary": "Сессия завершена успешно."
        }

# Глобальный экземпляр оркестратора
orchestrator = None

# Функция для использования в API
def handle_request(request_type, content, specialist=None, **kwargs):
    """
    Обработка запросов к центральному агенту
    
    Args:
        request_type: Тип запроса ('start', 'continue', 'execute_seo', 'shell', 'python', etc.)
        content: Содержимое запроса
        specialist: Ключ специалиста (для execute)
        **kwargs: Дополнительные параметры для различных типов запросов
        
    Returns:
        Результат обработки запроса
    """
    global orchestrator
    
    if orchestrator is None:
        orchestrator = CentralOrchestrator()
        
    if request_type == "start":
        return orchestrator.start_session(content)
    elif request_type == "continue":
        return orchestrator.continue_conversation(content)
    elif request_type == "execute_seo":
        return orchestrator.execute_seo_task(content)
    elif request_type == "shell":
        return orchestrator.execute_shell_command(content)
    elif request_type == "list_files":
        path = content if content else None
        return orchestrator.list_files(path)
    elif request_type == "read_file":
        return orchestrator.read_file(content)
    elif request_type == "write_file":
        return orchestrator.write_file(content, kwargs.get("file_content", ""))
    elif request_type == "run_program":
        return orchestrator.run_program(content, kwargs.get("args", None))
    elif request_type == "download_file":
        return orchestrator.download_file(content, kwargs.get("destination", None))
    elif request_type == "open_browser":
        return orchestrator.open_in_browser(content)
    elif request_type == "process_list":
        return orchestrator.get_process_list()
    elif request_type == "create_script":
        return orchestrator.create_and_run_script(
            content,
            kwargs.get("script_type", "python"),
            kwargs.get("args", None)
        )
    elif request_type == "python":
        return orchestrator.execute_python_code(content)
    elif request_type == "end":
        return orchestrator.end_session()
    else:
        return {"error": f"Неизвестный тип запроса: {request_type}"}

# Тестовая функция
def test_orchestrator():
    print("Тестирование центрального агента-оркестратора...")
    
    agent = CentralOrchestrator()
    
    # Тест начала сессии
    print("\n=== Начало сессии ===")
    response = agent.start_session("Привет! Что ты умеешь делать?")
    print(f"Ответ: {response['response']}")
    print(f"Статистика использования: {response['usage']}")
    
    # Тест продолжения беседы
    print("\n=== Продолжение беседы ===")
    response = agent.continue_conversation("Можешь ли ты выполнять системные команды?")
    print(f"Ответ: {response['response']}")
    print(f"Статистика использования: {response['usage']}")
    
    # Тест выполнения shell-команды
    print("\n=== Выполнение shell-команды ===")
    response = agent.execute_shell_command("dir")
    print(f"Результат: {response.get('result', '')[:100]}...")
    
    # Тест чтения файла
    print("\n=== Чтение файла ===")
    try:
        # Создаем тестовый файл
        with open("test_file.txt", "w", encoding="utf-8") as f:
            f.write("Тестовый контент для чтения")
        
        response = agent.read_file("test_file.txt")
        print(f"Содержимое: {response.get('content', '')}")
    except Exception as e:
        print(f"Ошибка при тестировании чтения файла: {e}")
    finally:
        # Удаляем тестовый файл
        try:
            os.remove("test_file.txt")
        except:
            pass
    
    # Тест создания и запуска скрипта
    print("\n=== Создание и запуск скрипта ===")
    script_content = """
print("Привет из тестового скрипта!")
import os
print(f"Текущая директория: {os.getcwd()}")
"""
    response = agent.create_and_run_script(script_content)
    print(f"Stdout: {response.get('stdout', '')}")
    
    # Завершение сессии
    print("\n=== Завершение сессии ===")
    final_stats = agent.end_session()
    print(f"Итоговая статистика: {final_stats}")
    
    return "Тестирование завершено"

if __name__ == "__main__":
    test_orchestrator()
